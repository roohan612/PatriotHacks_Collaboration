import pygame
import sys
import time
import random
from linalg import *

pygame.init()

class tile_map_t:
    def __init__(self : "tile_map_t") -> None:
        self.surface : pygame.Surface = pygame.image.load("assets\\map\\map.png")
        self.surface.set_colorkey((0, 0, 0))
        self.rects : tuple[pygame.Rect] = (
            pygame.Rect(0, 0, 32, 576),
            pygame.Rect(32, 0, 960, 32),
            pygame.Rect(96, 224, 192, 32),
            pygame.Rect(96, 416, 192, 32),
            pygame.Rect(384, 320, 256, 32),
            pygame.Rect(384, 512, 256, 32),
            pygame.Rect(736, 224, 192, 32),
            pygame.Rect(736, 416, 192, 32),
            pygame.Rect(32, 544, 960, 32),
            pygame.Rect(992, 0, 32, 576)
        )

        
                    
class lazer_t:
    def __init__(self : "lazer_t", x : float, y : float, dx : float = 1.0) -> None:
        self.x : float = x
        self.y : float = y
        self.dx : float = dx
    

class player_t:

    IMAGE_DIR : str = "assets\\images\\entities\\player.png"
    IMAGE : pygame.Surface = pygame.image.load(IMAGE_DIR)

    ANIMATION : dict[str, pygame.Rect] = [
        {
            "right":[
                pygame.Rect(0, 0,  52, 64),
                pygame.Rect(0, 64, 52, 64),
                pygame.Rect(0, 128, 52, 64),
                pygame.Rect(0, 192, 52, 64)
            ],
            "left":[
                pygame.Rect(52, 0,  52, 64),
                pygame.Rect(52, 64, 52, 64),
                pygame.Rect(52, 128, 52, 64),
                pygame.Rect(52, 192, 52, 64)
            ]
        },
        {
            "right":[
                pygame.Rect(104, 0,  52, 64),
                pygame.Rect(104, 64, 52, 64),
                pygame.Rect(104, 128, 52, 64),
                pygame.Rect(104, 192, 52, 64)
            ],
            "left":[
                pygame.Rect(156, 0,  52, 64),
                pygame.Rect(156, 64, 52, 64),
                pygame.Rect(156, 128, 52, 64),
                pygame.Rect(156, 192, 52, 64)
            ]
        }
    ]
    H_ACCELERATION : float = 16.0
    MAX_VELOCITY : float = 4.0
    GRAVITY : float = 16.0
    JUMP_VELOCITY : float = -12.0

    ANIMATION_SLIDE : int = 0
    TIME_STAMP : float = 0.0
    TIME_DURATION : float = 0.10

    

    def __init__(self : "player_t") -> None:
        self.rect : pygame.Rect = pygame.Rect(64, 64, 52, 64)
        self.velocity : vec2 = vec2(0.0, 0.0)
        self.jumping : bool = False

        self.health : int = 100
        self.status : str = "left"
        self.lazer_cooldown : float = 0.0

        self.lazers : list[lazer_t] = []


    def controls(self : "player_t", app : "app_t") -> None:
        keys = pygame.key.get_pressed()
        hmove : bool = False
        if keys[pygame.K_a]:
            hmove = True
            self.velocity.x = max(-self.MAX_VELOCITY, self.velocity.x - self.H_ACCELERATION * app.delta_time)
            self.status = "left"
        if keys[pygame.K_d]:
            hmove = True
            self.velocity.x = min(self.MAX_VELOCITY, self.velocity.x + self.H_ACCELERATION * app.delta_time)
            self.status = "right"
        if keys[pygame.K_w] and not self.jumping:
            self.jumping = not self.jumping
            self.velocity.y = self.JUMP_VELOCITY
        if keys[pygame.K_RIGHT]:
            self.status = "right"
        if keys[pygame.K_LEFT]:
            self.status = "left"
        if keys[pygame.K_SPACE]:
            if self.status == "left":
                self.lazers.append(lazer_t(self.rect.x, self.rect.y, -64))
            else:
                self.lazers.append(lazer_t(self.rect.x, self.rect.y,  64))
        if not hmove:
            self.velocity.x *= app.delta_time
            self.ANIMATION_SLIDE = 0
        if (hmove or self.jumping) and app.time > self.TIME_STAMP:
            self.TIME_STAMP = app.time + self.TIME_DURATION
            self.ANIMATION_SLIDE = (self.ANIMATION_SLIDE + 1) % 4
        
        
        self.velocity.y += self.GRAVITY * app.delta_time


# animation database
animation_database = {}

walking_frames = "frame1.png"
dash_frames = 'dash.png'
jumping_frames = "jump1.png"
shooting_frames = "shooting1.png"
enemy_shoot_frames = 'enemy_shooting.png'
player_hit_health_frame = 'hit_health_frame.png'
enemy_hit_health_frame = 'enemy_hit_health_frame.png'
# screen goes all red
player_death_screen = 'death_screen.pmg'
# enemy disappears
enemy_death = 'enemy_death.png'

 # Define enemy class
class enemy:
    ANIMATION: dict[str, pygame.Rect] = {
        "right": pygame.Rect(26, 0, 26, 32),
        "left": pygame.Rect(0, 0, 26, 32)
    }

    H_ACCELERATION: float = 32.0
    GRAVITY: float = 32.0
    JUMP_VELOCITY: float = -16.0

    # Define the display_r variable as a Rect
    enemies = [enemy(400, 300), enemy(600, 300), enemy(800, 300)]
    display_r = pygame.Rect(0, 0, 32 * 32, 32 * 18)

    def __init__(self, x, y):
        self.rect = pygame.Rect(x, y, 32, 32)
        self.y_velocity = 0

    def update(self, player_rect):
        self.y_velocity += 0.2

    def enemy_update(self):
        for enemy_instance in enemy.enemies:
            enemy_instance.update(self.player.rect)
            enemy_instance.rect.y += enemy_instance.y_velocity
            self.tile_map.surface.blit(self_enemy_image, enemy_instance.rect)
            if enemy.rect.colliderect(player_rect):
                pass
            if enemy.rect.x < player_rect.x:
                enemy.rect.x += enemy_speed
            elif enemy.rect.x > player_rect.x:
                enemy.rect.x -= enemy_speed


    ENEMY_DIR: str = "/Users/roohanahmed/Documents/PatriotHacks/exploit/assets/enemy.png"
    enemy_image: pygame.Surface = pygame.image.load(ENEMY_DIR)
    for i in range(5):
        for enemy in enemies:
            enemy.update(player_t)
            enemy.rect.y += enemy.y_velocity
            # check for collision with display_r and enemy
            if display_r.colliderect(enemy.rect):
                pass
                # placeholder value for gravity
                enemies[0] += 0.2
                # enemies cannot fall faster than 3 pixels
                if enemies[0] > 3:
                    enemies[0] = 3
                # movement of enemy indexes its vertical velocity
                enemy_movement = [0, enemy[0]]
                if player.x > enemy[1].x + 5:
                    enemy_movement[0] = 1
                if player.x < enemy[1].x - 5:
                    enemy_movement[0] = -1
                collision_types = enemy[1].move(enemy_movement, tile_rect)
                # stop enemies vert velocity once it hits ground
                if collision_types['bottom'] == True:
                    enemy[0] = 0
                # render enemies
                enemy[1].display(display, scroll)
                # if player collides with enemy
                if player.obj.rect.colliderect(enemy[1].obj.rect):
                    vertical_momentum = -4


class app_t:
    BACKGROUND_IMAGE_DIR : str = "assets\\images\\background\\background.png"
    BACKGROUND_IMAGE : pygame.Surface = pygame.image.load(BACKGROUND_IMAGE_DIR)

    def __init__(self : "app_t") -> None:
        # handling window
        self.window : pygame.Surface            = pygame.display.set_mode()
        self.draw_surface : pygame.Surface      = pygame.Surface(self.BACKGROUND_IMAGE.get_size())
        self.FRAME_RATE : int                   = 60
        self.time : float                       = 0.0
        self.delta_time : float                 = 0.0
        self.clock : pygame.time.Clock          = pygame.time.Clock()
        
        self.WINDOW_SIZE : tuple[int, int]      = self.window.get_size()

        # player
        self.player : player_t                  = player_t()

        # tile_map
        self.tile_map : tile_map_t = tile_map_t()


    def run(self : "app_t") -> None:
        self.time = time.time() 
        while True:
            self.update_time()
            self.poll_events()
            self.player_update()
            self.update_lazers()
            
            


            self.clear()
            self.draw_surface.blit(self.tile_map.surface, (0, 0))
            self.draw_surface.blit(player_t.IMAGE, self.player.rect, self.player.ANIMATION[self.player.jumping][self.player.status][self.player.ANIMATION_SLIDE])



            [pygame.draw.line(self.draw_surface, (255, 0, 0), (lazer.x, lazer.y), (lazer.x + lazer.dx, lazer.y), 1) for lazer in self.player.lazers]

            #pygame.draw.rect(self.draw_surface, (255, 0, 0), self.player.rect, 1)

            #for rect in self.tile_map.rects:
            #    pygame.draw.rect(self.draw_surface, (255, 0, 0), rect, 1)


            self.update()


    
    def handle_event(self : "app_t", event : pygame.event.Event) -> None:
        # do event handling here
        pass



    def poll_events(self : "app_t") -> None:
        [exit(0) for event in pygame.event.get() if event.type == pygame.QUIT]



    def update_time(self : "app_t") -> None:
        current_time : float = time.time()
        self.delta_time = current_time - self.time
        self.time = current_time



    def update(self : "app_t") -> None:
        self.window.blit(pygame.transform.scale(self.draw_surface, self.WINDOW_SIZE), (0, 0))
        pygame.display.update()
        self.clock.tick(self.FRAME_RATE)



    def clear(self : "app_t") -> None:
        self.draw_surface.blit(self.BACKGROUND_IMAGE, (0, 0))


    def player_update(self : "app_t") -> None:
        self.player.controls(self)
        self.player.rect.x += self.player.velocity.x
            
        for rect in self.tile_map.rects:
            if rect.colliderect(self.player.rect):
                if self.player.velocity.x > 0:
                    self.player.rect.right = rect.left
                    self.player.velocity.x = 0
                elif self.player.velocity.x < 0:
                    self.player.rect.left = rect.right
                    self.player.velocity.x = 0
                break
        
        self.player.rect.y += self.player.velocity.y
        for rect in self.tile_map.rects:
            if rect.colliderect(self.player.rect):
                if self.player.velocity.y > 0:
                    self.player.rect.bottom = rect.top
                    self.player.jumping = False
                    self.player.velocity.y = 0
                elif self.player.velocity.y < 0:
                    self.player.rect.top = rect.bottom
                    self.player.velocity.y = 0
                break


    def update_lazers(self : "app_t") -> None:
        for i in range(len(self.player.lazers) - 1, -1, -1):
            self.player.lazers[i].x += 64 * self.player.lazers[i].dx * self.delta_time
            for rect in self.tile_map.rects:
                if rect.collidepoint(self.player.lazers[i].x, self.player.lazers[i].y):
                    self.player.lazers.pop(i)
                    break

            

            

if __name__ == "__main__":
    app = app_t()
    app.run()

