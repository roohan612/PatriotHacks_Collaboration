import math

__all__ : tuple[str, ...] = (
    "vec_type",
    "mat_type",
    "vec2",
    "vec3",
    "vec4",
    "mat2",
    "mat3",
    "mat4",
    "mag_sqrd",
    "mag",
    "inv_mag_sqrd",
    "inv_mag",
    "normalize",
    "dot",
    "cross",
    "lerp",
    "reflect",
    "to_vec2",
    "to_vec3",
    "to_vec4",
    "rot_mat2_lhs",
    "rot_mat2_rhs",
    "rot_mat3_lhs",
    "rot_mat3_rhs",
    "polar"
)


class vec_type: pass
class mat_type: pass


class vec2(vec_type):
    __slots__ : tuple[str, ...] = ('x', 'y')
    def __init__(self : "vec2", x : float | int = 0.0, y : float | int = 0.0) -> None:
        if isinstance(x, float):
            self.x : float = x
        elif isinstance(x, int):
            self.x : float = float(x)
        else:
            raise ValueError("y has to be either 'float' or 'int'")

        if isinstance(y, float):
            self.y : float = y
        elif isinstance(y, int):
            self.y : float = float(y)
        else:
            raise ValueError("y has to be either 'float' or 'int'")


    def get_x(self : "vec2") -> float:
        return self.x


    def set_x(self : "vec2", x : float) -> None:
        self.x = x

    
    def __getitem__(self : "vec2", index : int) -> float:
        return self.__getattribute__(self.__slots__[index])


    def __setitem__(self : "vec2", index : int, value : float) -> None:
        self.__setattr__(self.__slots__[index], value)
    

    def __len__(self : "vec2") -> int:
        return 2


    def __str__(self : "vec2") -> str:
        return "< {:.1f}, {:.1f} >".format(*self)


    def __add__(self : "vec2", other : "vec2 | float | int") -> "vec2":
        if isinstance(other, vec2):
            return vec2(self.x + other.x, self.y + other.y)
        if isinstance(other, (float, int)):
            return vec2(self.x + other, self.y + other)
        return NotImplemented


    def __sub__(self : "vec2", other : "vec2 | float | int") -> "vec2":
        if isinstance(other, vec2):
            return vec2(self.x - other.x, self.y - other.y)
        if isinstance(other, (float, int)):
            return vec2(self.x - other, self.y - other)
        return NotImplemented


    def __mul__(self : "vec2", other : "vec2 | float | int") -> "vec2":
        if isinstance(other, vec2):
            return vec2(self.x * other.x, self.y * other.y)
        if isinstance(other, (float, int)):
            return vec2(self.x * other, self.y * other)
        return NotImplemented


    def __truediv__(self : "vec2", other : "vec2 | float | int") -> "vec2":
        if isinstance(other, vec2):
            return vec2(self.x / other.x, self.y / other.y)
        if isinstance(other, (float, int)):
            return vec2(self.x / other, self.y / other)
        return NotImplemented


    def __floordiv__(self : "vec2", other : "vec2 | float | int") -> "vec2":
        if isinstance(other, vec2):
            return vec2(self.x // other.x, self.y // other.y)
        if isinstance(other, (float, int)):
            return vec2(self.x // other, self.y // other)
        return NotImplemented


    def __mod__(self : "vec2", other : "vec2 | float | int") -> "vec2":
        if isinstance(other, vec2):
            return vec2(self.x % other.x, self.y % other.y)
        if isinstance(other, (float, int)):
            return vec2(self.x % other, self.y % other)
        return NotImplemented


    def __pow__(self : "vec2", other : "vec2 | float | int") -> "vec2":
        if isinstance(other, vec2):
            return vec2(self.x ** other.x, self.y ** other.y)
        if isinstance(other, (float, int)):
            return vec2(self.x ** other, self.y ** other)
        return NotImplemented


    def __radd__(self : "vec2", other : float | int) -> "vec2":
        if isinstance(other, (float, int)):
            return vec2(other + self.x, other + self.y)
        return NotImplemented

    
    def __rsub__(self : "vec2", other : float | int) -> "vec2":
        if isinstance(other, (float, int)):
            return vec2(other - self.x, other - self.y)
        return NotImplemented

    
    def __rmul__(self : "vec2", other : float | int) -> "vec2":
        if isinstance(other, (float, int)):
            return vec2(other * self.x, other * self.y)
        return NotImplemented

    
    def __rtruediv__(self : "vec2", other : float | int) -> "vec2":
        if isinstance(other, (float, int)):
            return vec2(other / self.x, other / self.y)
        return NotImplemented

    
    def __rfloordiv__(self : "vec2", other : float | int) -> "vec2":
        if isinstance(other, (float, int)):
            return vec2(other // self.x, other // self.y)
        return NotImplemented

    
    def __rmod__(self : "vec2", other : float | int) -> "vec2":
        if isinstance(other, (float, int)):
            return vec2(other % self.x, other % self.y)
        return NotImplemented

    
    def __rpow__(self : "vec2", other : float | int) -> "vec2":
        if isinstance(other, (float, int)):
            return vec2(other ** self.x, other ** self.y)
        return NotImplemented

    
    def __iadd__(self : "vec2", other : "vec2 | float | int") -> "vec2":
        if isinstance(other, vec2):
            self.x += other.x; self.y += other.y; return self
        if isinstance(other, (float, int)):
            self.x += other; self.y += other; return self
        return NotImplemented


    def __isub__(self : "vec2", other : "vec2 | float | int") -> "vec2":
        if isinstance(other, vec2):
            self.x -= other.x; self.y -= other.y; return self
        if isinstance(other, (float, int)):
            self.x -= other; self.y -= other; return self
        return NotImplemented


    def __imul__(self : "vec2", other : "vec2 | float | int") -> "vec2":
        if isinstance(other, vec2):
            self.x *= other.x; self.y *= other.y; return self
        if isinstance(other, (float, int)):
            self.x *= other; self.y *= other; return self
        return NotImplemented


    def __itruediv__(self : "vec2", other : "vec2 | float | int") -> "vec2":
        if isinstance(other, vec2):
            self.x /= other.x; self.y /= other.y; return self
        if isinstance(other, (float, int)):
            self.x /= other; self.y /= other; return self
        return NotImplemented


    def __ifloordiv__(self : "vec2", other : "vec2 | float | int") -> "vec2":
        if isinstance(other, vec2):
            self.x //= other.x; self.y //= other.y; return self
        if isinstance(other, (float, int)):
            self.x //= other; self.y //= other; return self
        return NotImplemented


    def __imod__(self : "vec2", other : "vec2 | float | int") -> "vec2":
        if isinstance(other, vec2):
            self.x %= other.x; self.y %= other.y; return self
        if isinstance(other, (float, int)):
            self.x %= other; self.y %= other; return self
        return NotImplemented


    def __ipow__(self : "vec2", other : "vec2 | float | int") -> "vec2":
        if isinstance(other, vec2):
            self.x **= other.x; self.y **= other.y; return self
        if isinstance(other, (float, int)):
            self.x **= other; self.y **= other; return self
        return NotImplemented


    def __neg__(self : "vec2") -> "vec2":
        return vec2(-self.x, -self.y)


    def __pos__(self : "vec2") -> "vec2":
        return vec2(+self.x, +self.y)


    def to_int_pair(self : "vec2") -> tuple[int, int]:
        return (int(self.x), int(self.y))


class vec3(vec_type):
    __slots__ : tuple[str, ...] = ('x', 'y', 'z')
    def __init__(self : "vec3", x : float | int = 0.0, y : float | int = 0.0, z : float | int = 0.0) -> None:
        if isinstance(x, float):
            self.x : float = x
        elif isinstance(x, int):
            self.x : float = float(x)
        else:
            raise ValueError("y has to be either 'float' or 'int'")

        if isinstance(y, float):
            self.y : float = y
        elif isinstance(y, int):
            self.y : float = float(y)
        else:
            raise ValueError("y has to be either 'float' or 'int'")


        if isinstance(z, float):
            self.z : float = z
        elif isinstance(z, int):
            self.z : float = float(z)
        else:
            raise ValueError("z has to be either 'float' or 'int'")


    def __getitem__(self : "vec3", index : int) -> float:
        return self.__getattribute__(self.__slots__[index])


    def __setitem__(self : "vec3", index : int, value : float) -> None:
        self.__setattr__(self.__slots__[index], value)
    

    def __len__(self : "vec3") -> int:
        return 3


    def __str__(self : "vec3") -> str:
        return "< {:.1f}, {:.1f}, {:.1f} >".format(*self)


    def __add__(self : "vec3", other : "vec3 | float | int") -> "vec3":
        if isinstance(other, vec3):
            return vec3(self.x + other.x, self.y + other.y, self.z + other.z)
        if isinstance(other, (float, int)):
            return vec3(self.x + other, self.y + other, self.z + other)
        return NotImplemented


    def __sub__(self : "vec3", other : "vec3 | float | int") -> "vec3":
        if isinstance(other, vec3):
            return vec3(self.x - other.x, self.y - other.y, self.z - other.z)
        if isinstance(other, (float, int)):
            return vec3(self.x - other, self.y - other, self.z - other)
        return NotImplemented


    def __mul__(self : "vec3", other : "vec3 | float | int") -> "vec3":
        if isinstance(other, vec3):
            return vec3(self.x * other.x, self.y * other.y, self.z * other.z)
        if isinstance(other, (float, int)):
            return vec3(self.x * other, self.y * other, self.z * other)
        return NotImplemented


    def __truediv__(self : "vec3", other : "vec3 | float | int") -> "vec3":
        if isinstance(other, vec3):
            return vec3(self.x / other.x, self.y / other.y, self.z / other.z)
        if isinstance(other, (float, int)):
            return vec3(self.x / other, self.y / other, self.z / other)
        return NotImplemented


    def __floordiv__(self : "vec3", other : "vec3 | float | int") -> "vec3":
        if isinstance(other, vec3):
            return vec3(self.x // other.x, self.y // other.y, self.z // other.z)
        if isinstance(other, (float, int)):
            return vec3(self.x // other, self.y // other, self.z // other)
        return NotImplemented


    def __mod__(self : "vec3", other : "vec3 | float | int") -> "vec3":
        if isinstance(other, vec3):
            return vec3(self.x % other.x, self.y % other.y, self.z % other.z)
        if isinstance(other, (float, int)):
            return vec3(self.x % other, self.y % other, self.z % other)
        return NotImplemented


    def __pow__(self : "vec3", other : "vec3 | float | int") -> "vec3":
        if isinstance(other, vec3):
            return vec3(self.x ** other.x, self.y ** other.y, self.z ** other.z)
        if isinstance(other, (float, int)):
            return vec3(self.x ** other, self.y ** other, self.z ** other)
        return NotImplemented


    def __radd__(self : "vec3", other : float | int) -> "vec3":
        if isinstance(other, (float, int)):
            return vec3(other + self.x, other + self.y, other + self.z)
        return NotImplemented

    
    def __rsub__(self : "vec3", other : float | int) -> "vec3":
        if isinstance(other, (float, int)):
            return vec3(other - self.x, other - self.y, other - self.z)
        return NotImplemented

    
    def __rmul__(self : "vec3", other : float | int) -> "vec3":
        if isinstance(other, (float, int)):
            return vec3(other * self.x, other * self.y, other * self.z)
        return NotImplemented

    
    def __rtruediv__(self : "vec3", other : float | int) -> "vec3":
        if isinstance(other, (float, int)):
            return vec3(other / self.x, other / self.y, other / self.z)
        return NotImplemented

    
    def __rfloordiv__(self : "vec3", other : float | int) -> "vec3":
        if isinstance(other, (float, int)):
            return vec3(other // self.x, other // self.y, other // self.z)
        return NotImplemented

    
    def __rmod__(self : "vec3", other : float | int) -> "vec3":
        if isinstance(other, (float, int)):
            return vec3(other % self.x, other % self.y, other % self.z)
        return NotImplemented

    
    def __rpow__(self : "vec3", other : float | int) -> "vec3":
        if isinstance(other, (float, int)):
            return vec3(other ** self.x, other ** self.y, other ** self.z)
        return NotImplemented

    
    def __iadd__(self : "vec3", other : "vec3 | float | int") -> "vec3":
        if isinstance(other, vec3):
            self.x += other.x; self.y += other.y; self.z += other.z; return self
        if isinstance(other, (float, int)):
            self.x += other; self.y += other; self.z += other; return self
        return NotImplemented


    def __isub__(self : "vec3", other : "vec3 | float | int") -> "vec3":
        if isinstance(other, vec3):
            self.x -= other.x; self.y -= other.y; self.z -= other.z; return self
        if isinstance(other, (float, int)):
            self.x -= other; self.y -= other; self.z -= other; return self
        return NotImplemented


    def __imul__(self : "vec3", other : "vec3 | float | int") -> "vec3":
        if isinstance(other, vec3):
            self.x *= other.x; self.y *= other.y; self.z *= other.z; return self
        if isinstance(other, (float, int)):
            self.x *= other; self.y *= other; self.z *= other; return self
        return NotImplemented


    def __itruediv__(self : "vec3", other : "vec3 | float | int") -> "vec3":
        if isinstance(other, vec3):
            self.x /= other.x; self.y /= other.y; self.z /= other.z; return self
        if isinstance(other, (float, int)):
            self.x /= other; self.y /= other; self.z /= other; return self
        return NotImplemented


    def __ifloordiv__(self : "vec3", other : "vec3 | float | int") -> "vec3":
        if isinstance(other, vec3):
            self.x //= other.x; self.y //= other.y; self.z //= other.z; return self
        if isinstance(other, (float, int)):
            self.x //= other; self.y //= other; self.z //= other; return self
        return NotImplemented


    def __imod__(self : "vec3", other : "vec3 | float | int") -> "vec3":
        if isinstance(other, vec3):
            self.x %= other.x; self.y %= other.y; self.z %= other.z; return self
        if isinstance(other, (float, int)):
            self.x %= other; self.y %= other; self.z %= other; return self
        return NotImplemented


    def __ipow__(self : "vec3", other : "vec3 | float | int") -> "vec3":
        if isinstance(other, vec3):
            self.x **= other.x; self.y **= other.y; self.z **= other.z; return self
        if isinstance(other, (float, int)):
            self.x **= other; self.y **= other; self.z **= other; return self
        return NotImplemented


    def __neg__(self : "vec3") -> "vec3":
        return vec3(-self.x, -self.y, -self.z)


    def __pos__(self : "vec3") -> "vec3":
        return vec3(+self.x, +self.y, +self.z)


    def to_int_pair(self : "vec3") -> tuple[int, int]:
        return (int(self.x), int(self.y))


class vec4(vec_type):
    __slots__ : tuple[str, ...] = ('x', 'y', 'z', 'w')
    def __init__(self : "vec4", x : float | int = 0.0, y : float | int = 0.0, z : float | int = 0.0, w : float | int = 0.0) -> None:
        if isinstance(x, float):
            self.x : float = x
        elif isinstance(x, int):
            self.x : float = float(x)
        else:
            raise ValueError("y has to be either 'float' or 'int'")

        if isinstance(y, float):
            self.y : float = y
        elif isinstance(y, int):
            self.y : float = float(y)
        else:
            raise ValueError("y has to be either 'float' or 'int'")


        if isinstance(z, float):
            self.z : float = z
        elif isinstance(z, int):
            self.z : float = float(z)
        else:
            raise ValueError("z has to be either 'float' or 'int'")


        if isinstance(w, float):
            self.w : float = w
        elif isinstance(w, int):
            self.w : float = float(w)
        else:
            raise ValueError("w has to be either 'float' or 'int'")


    def __getitem__(self : "vec4", index : int) -> float:
        return self.__getattribute__(self.__slots__[index])


    def __setitem__(self : "vec4", index : int, value : float) -> None:
        self.__setattr__(self.__slots__[index], value)
    

    def __len__(self : "vec4") -> int:
        return 4


    def __str__(self : "vec4") -> str:
        return "< {:.1f}, {:.1f}, {:.1f}, {:.1f} >".format(*self)


    def __add__(self : "vec4", other : "vec4 | float | int") -> "vec4":
        if isinstance(other, vec4):
            return vec4(self.x + other.x, self.y + other.y, self.z + other.z, self.w + other.w)
        if isinstance(other, (float, int)):
            return vec4(self.x + other, self.y + other, self.z + other, self.w + other)
        return NotImplemented


    def __sub__(self : "vec4", other : "vec4 | float | int") -> "vec4":
        if isinstance(other, vec4):
            return vec4(self.x - other.x, self.y - other.y, self.z - other.z, self.w - other.w)
        if isinstance(other, (float, int)):
            return vec4(self.x - other, self.y - other, self.z - other, self.w - other)
        return NotImplemented


    def __mul__(self : "vec4", other : "vec4 | float | int") -> "vec4":
        if isinstance(other, vec4):
            return vec4(self.x * other.x, self.y * other.y, self.z * other.z, self.w * other.w)
        if isinstance(other, (float, int)):
            return vec4(self.x * other, self.y * other, self.z * other, self.w * other)
        return NotImplemented


    def __truediv__(self : "vec4", other : "vec4 | float | int") -> "vec4":
        if isinstance(other, vec4):
            return vec4(self.x / other.x, self.y / other.y, self.z / other.z, self.w / other.w)
        if isinstance(other, (float, int)):
            return vec4(self.x / other, self.y / other, self.z / other, self.w / other)
        return NotImplemented


    def __floordiv__(self : "vec4", other : "vec4 | float | int") -> "vec4":
        if isinstance(other, vec4):
            return vec4(self.x // other.x, self.y // other.y, self.z // other.z, self.w // other.w)
        if isinstance(other, (float, int)):
            return vec4(self.x // other, self.y // other, self.z // other, self.w // other)
        return NotImplemented


    def __mod__(self : "vec4", other : "vec4 | float | int") -> "vec4":
        if isinstance(other, vec4):
            return vec4(self.x % other.x, self.y % other.y, self.z % other.z, self.w % other.w)
        if isinstance(other, (float, int)):
            return vec4(self.x % other, self.y % other, self.z % other, self.w % other)
        return NotImplemented


    def __pow__(self : "vec4", other : "vec4 | float | int") -> "vec4":
        if isinstance(other, vec4):
            return vec4(self.x ** other.x, self.y ** other.y, self.z ** other.z, self.w ** other.w)
        if isinstance(other, (float, int)):
            return vec4(self.x ** other, self.y ** other, self.z ** other, self.w ** other)
        return NotImplemented


    def __radd__(self : "vec4", other : float | int) -> "vec4":
        if isinstance(other, (float, int)):
            return vec4(other + self.x, other + self.y, other + self.z, other + self.w)
        return NotImplemented

    
    def __rsub__(self : "vec4", other : float | int) -> "vec4":
        if isinstance(other, (float, int)):
            return vec4(other - self.x, other - self.y, other - self.z, other - self.w)
        return NotImplemented

    
    def __rmul__(self : "vec4", other : float | int) -> "vec4":
        if isinstance(other, (float, int)):
            return vec4(other * self.x, other * self.y, other * self.z, other * self.w)
        return NotImplemented

    
    def __rtruediv__(self : "vec4", other : float | int) -> "vec4":
        if isinstance(other, (float, int)):
            return vec4(other / self.x, other / self.y, other / self.z, other / self.w)
        return NotImplemented

    
    def __rfloordiv__(self : "vec4", other : float | int) -> "vec4":
        if isinstance(other, (float, int)):
            return vec4(other // self.x, other // self.y, other // self.z, other // self.w)
        return NotImplemented

    
    def __rmod__(self : "vec4", other : float | int) -> "vec4":
        if isinstance(other, (float, int)):
            return vec4(other % self.x, other % self.y, other % self.z, other % self.w)
        return NotImplemented

    
    def __rpow__(self : "vec4", other : float | int) -> "vec4":
        if isinstance(other, (float, int)):
            return vec4(other ** self.x, other ** self.y, other ** self.z, other ** self.w)
        return NotImplemented

    
    def __iadd__(self : "vec4", other : "vec4 | float | int") -> "vec4":
        if isinstance(other, vec4):
            self.x += other.x; self.y += other.y; self.z += other.z; self.w += other.w; return self
        if isinstance(other, (float, int)):
            self.x += other; self.y += other; self.z += other; self.w += other; return self
        return NotImplemented


    def __isub__(self : "vec4", other : "vec4 | float | int") -> "vec4":
        if isinstance(other, vec4):
            self.x -= other.x; self.y -= other.y; self.z -= other.z; self.w -= other.w; return self
        if isinstance(other, (float, int)):
            self.x -= other; self.y -= other; self.z -= other; self.w -= other; return self
        return NotImplemented


    def __imul__(self : "vec4", other : "vec4 | float | int") -> "vec4":
        if isinstance(other, vec4):
            self.x *= other.x; self.y *= other.y; self.z *= other.z; self.w *= other.w; return self
        if isinstance(other, (float, int)):
            self.x *= other; self.y *= other; self.z *= other; self.w *= other; return self
        return NotImplemented


    def __itruediv__(self : "vec4", other : "vec4 | float | int") -> "vec4":
        if isinstance(other, vec4):
            self.x /= other.x; self.y /= other.y; self.z /= other.z; self.w /= other.w; return self
        if isinstance(other, (float, int)):
            self.x /= other; self.y /= other; self.z /= other; self.w /= other; return self
        return NotImplemented


    def __ifloordiv__(self : "vec4", other : "vec4 | float | int") -> "vec4":
        if isinstance(other, vec4):
            self.x //= other.x; self.y //= other.y; self.z //= other.z; self.w //= other.w; return self
        if isinstance(other, (float, int)):
            self.x //= other; self.y //= other; self.z //= other; self.w //= other; return self
        return NotImplemented


    def __imod__(self : "vec4", other : "vec4 | float | int") -> "vec4":
        if isinstance(other, vec4):
            self.x %= other.x; self.y %= other.y; self.z %= other.z; self.w %= other.w; return self
        if isinstance(other, (float, int)):
            self.x %= other; self.y %= other; self.z %= other; self.w %= other; return self
        return NotImplemented


    def __ipow__(self : "vec4", other : "vec4 | float | int") -> "vec4":
        if isinstance(other, vec4):
            self.x **= other.x; self.y **= other.y; self.z **= other.z; self.w **= other.w; return self
        if isinstance(other, (float, int)):
            self.x **= other; self.y **= other; self.z **= other; self.w **= other; return self
        return NotImplemented


    def __neg__(self : "vec4") -> "vec4":
        return vec4(-self.x, -self.y, -self.z, -self.w)


    def __pos__(self : "vec4") -> "vec4":
        return vec4(+self.x, +self.y, +self.z, +self.w)


    def to_int_pair(self : "vec4") -> tuple[int, int]:
        return (int(self.x), int(self.y))


class mat2(mat_type):
    __slots__ : tuple[str, ...] = ('x', 'y')
    def __init__(self : "mat2", x : vec2 = vec2(1.0, 0.0), y : vec2 = vec2(0.0, 1.0)) -> None:
        if isinstance(x, vec2):
            self.x : vec2 = x
        else:
            raise ValueError("x has to a 'vec2' type")

        if isinstance(y, vec2):
            self.y : vec2 = y
        else:
            raise ValueError("y has to a 'vec2' type")


    def __getitem__(self : "mat2", index : int) -> vec2:
        return self.__getattribute__(self.__slots__[index])


    def __setitem__(self : "mat2", index : int, value : vec2) -> None:
        self.__setattr__(self.__slots__[index], value)
    

    def __len__(self : "mat2") -> int:
        return 2


    def __str__(self : "mat2") -> str:
        return "[{:.1f}, {:.1f}],\n[{:.1f}, {:.1f}]".format(*self.x, *self.y)
        

    def __add__(self : "mat2", other : "mat2 | float | int") -> "mat2":
        if isinstance(other, mat2):
            return mat2(self.x + other.x, self.y + other.y)
        if isinstance(other, (float, int)):
            return mat2(self.x + other, self.y + other)
        return NotImplemented


    def __sub__(self : "mat2", other : "mat2 | float | int") -> "mat2":
        if isinstance(other, mat2):
            return mat2(self.x - other.x, self.y - other.y)
        if isinstance(other, (float, int)):
            return mat2(self.x - other, self.y - other)
        return NotImplemented


    def __mul__(self : "mat2", other : "mat2 | vec2 | float | int") -> "mat2 | vec2":
        if isinstance(other, mat2):
            return mat2(vec2(self.x.x * other.x.x + self.x.y * other.y.x, self.x.x * other.x.y + self.x.y * other.y.y), vec2(self.y.x * other.x.x + self.y.y * other.y.x, self.y.x * other.x.y + self.y.y * other.y.y))
        if isinstance(other, vec2):
            return vec2(self.x.x * other.x + self.x.y * other.y, self.y.x * other.x + self.y.y * other.y)
        if isinstance(other, (float, int)):
            return mat2(self.x * other, self.y * other)
        return NotImplemented


    def __radd__(self : "mat2", other : float | int) -> "mat2":
        if isinstance(other, (float, int)):
            return mat2(other + self.x, other + self.x)
        return NotImplemented

    
    def __rsub__(self : "mat2", other : float | int) -> "mat2":
        if isinstance(other, (float, int)):
            return mat2(other - self.x, other - self.y)
        return NotImplemented


    def __rmul__(self : "mat2", other : vec2 | float | int) -> "mat2 | vec2":
        if isinstance(other, vec2):
            return vec2(other.x * self.x.x + other.y * self.y.x, other.x * self.x.y + other.y * self.y.y)
        if isinstance(other, (float, int)):
            return mat2(other * self.x, other * self.y)
        return NotImplemented

    
    def __iadd__(self : "mat2", other : "mat2 | float | int") -> "mat2":
        if isinstance(other, mat2):
            self.x += other.x; self.y += other.y; return self
        if isinstance(other, (float, int)):
            self.x += other; self.y += other; return self
        return NotImplemented
    

    def __isub__(self : "mat2", other : "mat2 | float | int") -> "mat2":
        if isinstance(other, mat2):
            self.x -= other.x; self.y -= other.y; return self
        if isinstance(other, (float, int)):
            self.x -= other; self.y -= other; return self
        return NotImplemented
    

    def __imul__(self : "mat2", other : "mat2 | vec2 | float | int") -> "mat2 | vec2":
        if isinstance(other, mat2):
            self = self * other; return self
        if isinstance(other, vec2):
            r = self * other; other.x = r.x; other.y = r.y; return self
        if isinstance(other, (float, int)):
            self.x *= other; self.y *= other; return self
        return NotImplemented
    

    def __neg__(self : "mat2") -> "mat2":
        return mat2(-self.x, -self.y)


    def __pos__(self : "mat2") -> "mat2":
        return mat2(+self.x, +self.y)


class mat3(mat_type):
    __slots__ : tuple[str, ...] = ('x', 'y', 'z')
    def __init__(self : "mat3", x : vec3 = vec3(1.0, 0.0, 0.0), y : vec3 = vec3(0.0, 1.0, 0.0), z : vec3 = vec3(0.0, 0.0, 1.0)) -> None:
        if isinstance(x, vec3):
            self.x : vec3 = x
        else:
            raise ValueError("x has to a 'vec3' type")

        if isinstance(y, vec3):
            self.y : vec3 = y
        else:
            raise ValueError("y has to a 'vec3' type")

        if isinstance(z, vec3):
            self.z : vec3 = z
        else:
            raise ValueError("z has to a 'vec3' type")


    def __getitem__(self : "mat3", index : int) -> vec3:
        return self.__getattribute__(self.__slots__[index])


    def __setitem__(self : "mat3", index : int, value : vec3) -> None:
        self.__setattr__(self.__slots__[index], value)
    

    def __len__(self : "mat3") -> int:
        return 3


    def __str__(self : "mat3") -> str:
        return "[{:.1f}, {:.1f}, {:.1f}],\n[{:.1f}, {:.1f}, {:.1f}],\n[{:.1f}, {:.1f}, {:.1f}]".format(*self.x, *self.y, *self.z)
        

    def __add__(self : "mat3", other : "mat3 | float | int") -> "mat3":
        if isinstance(other, mat3):
            return mat3(self.x + other.x, self.y + other.y, self.z + other.z)
        if isinstance(other, (float, int)):
            return mat3(self.x + other, self.y + other, self.z + other)
        return NotImplemented


    def __sub__(self : "mat3", other : "mat3 | float | int") -> "mat3":
        if isinstance(other, mat3):
            return mat3(self.x - other.x, self.y - other.y, self.z - other.z)
        if isinstance(other, (float, int)):
            return mat3(self.x - other, self.y - other, self.z - other)
        return NotImplemented


    def __mul__(self : "mat3", other : "mat3 | vec3 | float | int") -> "mat3 | vec3":
        if isinstance(other, mat3):
            return mat3(vec3(self.x.x * other.x.x + self.x.y * other.y.x + self.x.z * other.z.x, self.x.x * other.x.y + self.x.y * other.y.y + self.x.z * other.z.y, self.x.x * other.x.z + self.x.y * other.y.z + self.x.z * other.z.z), vec3(self.y.x * other.x.x + self.y.y * other.y.x + self.y.z * other.z.x, self.y.x * other.x.y + self.y.y * other.y.y + self.y.z * other.z.y, self.y.x * other.x.z + self.y.y * other.y.z + self.y.z * other.z.z), vec3(self.z.x * other.x.x + self.z.y * other.y.x + self.z.z * other.z.x, self.z.x * other.x.y + self.z.y * other.y.y + self.z.z * other.z.y, self.z.x * other.x.z + self.z.y * other.y.z + self.z.z * other.z.z))
        if isinstance(other, vec3):
            return vec3(self.x.x * other.x + self.x.y * other.y + self.x.z * other.z, self.y.x * other.x + self.y.y * other.y + self.y.z * other.z, self.z.x * other.x + self.z.y * other.y + self.z.z * other.z)
        if isinstance(other, (float, int)):
            return mat3(self.x * other, self.y * other, self.z * other)
        return NotImplemented


    def __radd__(self : "mat3", other : float | int) -> "mat3":
        if isinstance(other, (float, int)):
            return mat3(other + self.x, other + self.x, other + self.z)
        return NotImplemented

    
    def __rsub__(self : "mat3", other : float | int) -> "mat3":
        if isinstance(other, (float, int)):
            return mat3(other - self.x, other - self.y, other - self.z)
        return NotImplemented


    def __rmul__(self : "mat3", other : vec3 | float | int) -> "mat3 | vec3":
        if isinstance(other, vec3):
            return vec3(other.x * self.x.x + other.y * self.y.x + other.z * self.z.x, other.x * self.x.y + other.y * self.y.y + other.z * self.z.y, other.x * self.x.z + other.y * self.y.z + other.z * self.z.z)
        if isinstance(other, (float, int)):
            return mat3(other * self.x, other * self.y, other * self.z)
        return NotImplemented

    
    def __iadd__(self : "mat3", other : "mat3 | float | int") -> "mat3":
        if isinstance(other, mat3):
            self.x += other.x; self.y += other.y; self.z += other.z; return self
        if isinstance(other, (float, int)):
            self.x += other; self.y += other; self.z += other; return self
        return NotImplemented
    

    def __isub__(self : "mat3", other : "mat3 | float | int") -> "mat3":
        if isinstance(other, mat3):
            self.x -= other.x; self.y -= other.y; self.z -= other.z; return self
        if isinstance(other, (float, int)):
            self.x -= other; self.y -= other; self.z -= other; return self
        return NotImplemented
    

    def __imul__(self : "mat3", other : "mat3 | vec3 | float | int") -> "mat3 | vec3":
        if isinstance(other, mat3):
            self = self * other; return self
        if isinstance(other, vec3):
            r = self * other; other.x = r.x; other.y = r.y; other.z = r.z; return self
        if isinstance(other, (float, int)):
            self.x *= other; self.y *= other; self.z *= other; return self
        return NotImplemented
    

    def __neg__(self : "mat3") -> "mat3":
        return mat3(-self.x, -self.y, -self.z)


    def __pos__(self : "mat3") -> "mat3":
        return mat3(+self.x, +self.y, +self.z)


class mat4(mat_type):
    __slots__ : tuple[str, ...] = ('x', 'y', 'z', 'w')
    def __init__(self : "mat4", x : vec4 = vec4(1.0, 0.0, 0.0, 0.0), y : vec4 = vec4(0.0, 1.0, 0.0, 0.0), z : vec4 = vec4(0.0, 0.0, 1.0, 0.0), w : vec4 = vec4(0.0, 0.0, 0.0, 1.0)) -> None:
        if isinstance(x, vec4):
            self.x : vec4 = x
        else:
            raise ValueError("x has to a 'vec4' type")

        if isinstance(y, vec4):
            self.y : vec4 = y
        else:
            raise ValueError("y has to a 'vec4' type")

        if isinstance(z, vec4):
            self.z : vec4 = z
        else:
            raise ValueError("z has to a 'vec4' type")

        if isinstance(w, vec4):
            self.w : vec4 = w
        else:
            raise ValueError("w has to a 'vec4' type")


    def __getitem__(self : "mat4", index : int) -> vec4:
        return self.__getattribute__(self.__slots__[index])


    def __setitem__(self : "mat4", index : int, value : vec4) -> None:
        self.__setattr__(self.__slots__[index], value)
    

    def __len__(self : "mat4") -> int:
        return 4


    def __str__(self : "mat4") -> str:
        return "[{:.1f}, {:.1f}, {:.1f}, {:.1f}],\n[{:.1f}, {:.1f}, {:.1f}, {:.1f}],\n[{:.1f}, {:.1f}, {:.1f}, {:.1f}],\n[{:.1f}, {:.1f}, {:.1f}, {:.1f}]".format(*self.x, *self.y, *self.z, *self.w)
        

    def __add__(self : "mat4", other : "mat4 | float | int") -> "mat4":
        if isinstance(other, mat4):
            return mat4(self.x + other.x, self.y + other.y, self.z + other.z, self.w + other.w)
        if isinstance(other, (float, int)):
            return mat4(self.x + other, self.y + other, self.z + other, self.w + other)
        return NotImplemented


    def __sub__(self : "mat4", other : "mat4 | float | int") -> "mat4":
        if isinstance(other, mat4):
            return mat4(self.x - other.x, self.y - other.y, self.z - other.z, self.w - other.w)
        if isinstance(other, (float, int)):
            return mat4(self.x - other, self.y - other, self.z - other, self.w + other)
        return NotImplemented


    def __mul__(self : "mat4", other : "mat4 | vec4 | float | int") -> "mat4 | vec4":
        if isinstance(other, mat4):
            return mat4(vec4(self.x.x * other.x.x + self.x.y * other.y.x + self.x.z * other.z.x + self.x.w * other.w.x, self.x.x * other.x.y + self.x.y * other.y.y + self.x.z * other.z.y + self.x.w * other.w.y, self.x.x * other.x.z + self.x.y * other.y.z + self.x.z * other.z.z + self.x.w * other.w.z, self.x.x * other.x.w + self.x.y * other.y.w + self.x.z * other.z.w + self.x.w * other.w.w), vec4(self.y.x * other.x.x + self.y.y * other.y.x + self.y.z * other.z.x + self.y.w * other.w.x, self.y.x * other.x.y + self.y.y * other.y.y + self.y.z * other.z.y + self.y.w * other.w.y, self.y.x * other.x.z + self.y.y * other.y.z + self.y.z * other.z.z + self.y.w * other.w.z, self.y.x * other.x.w + self.y.y * other.y.w + self.y.z * other.z.w + self.y.w * other.w.w), vec4(self.z.x * other.x.x + self.z.y * other.y.x + self.z.z * other.z.x + self.z.w * other.w.x, self.z.x * other.x.y + self.z.y * other.y.y + self.z.z * other.z.y + self.z.w * other.w.y, self.z.x * other.x.z + self.z.y * other.y.z + self.z.z * other.z.z + self.z.w * other.w.z, self.z.x * other.x.w + self.z.y * other.y.w + self.z.z * other.z.w + self.z.w * other.w.w), vec4(self.w.x * other.x.x + self.w.y * other.y.x + self.w.z * other.z.x + self.w.w * other.w.x, self.w.x * other.x.y + self.w.y * other.y.y + self.w.z * other.z.y + self.w.w * other.w.y, self.w.x * other.x.z + self.w.y * other.y.z + self.w.z * other.z.z + self.w.w * other.w.z, self.w.x * other.x.w + self.w.y * other.y.w + self.w.z * other.z.w + self.w.w * other.w.w))
        if isinstance(other, vec4):
            return vec4(self.x.x * other.x + self.x.y * other.y + self.x.z * other.z + self.x.w * other.w, self.y.x * other.x + self.y.y * other.y + self.y.z * other.z + self.y.w * other.w, self.z.x * other.x + self.z.y * other.y + self.z.z * other.z + self.z.w * other.w, self.w.x * other.x + self.w.y * other.y + self.w.z * other.z + self.w.w * other.w)
        if isinstance(other, (float, int)):
            return mat4(self.x * other, self.y * other, self.z * other, self.w * other)
        return NotImplemented


    def __radd__(self : "mat4", other : float | int) -> "mat4":
        if isinstance(other, (float, int)):
            return mat4(other + self.x, other + self.x, other + self.z, other + self.w)
        return NotImplemented

    
    def __rsub__(self : "mat4", other : float | int) -> "mat4":
        if isinstance(other, (float, int)):
            return mat4(other - self.x, other - self.y, other - self.z, other - self.w)
        return NotImplemented


    def __rmul__(self : "mat4", other : vec4 | float | int) -> "mat4 | vec4":
        if isinstance(other, vec4):
            return vec4(
                other.x * self.x.x + other.y * self.y.x + other.z * self.z.x + other.w * self.w.x,
                other.x * self.x.y + other.y * self.y.y + other.z * self.z.y + other.w * self.w.y,
                other.x * self.x.z + other.y * self.y.z + other.z * self.z.z + other.w * self.w.z,
                other.x * self.x.w + other.y * self.y.w + other.z * self.z.w + other.w * self.w.w
            )
        if isinstance(other, (float, int)):
            return mat4(other * self.x, other * self.y, other * self.z, other * self.w)
        return NotImplemented

    
    def __iadd__(self : "mat4", other : "mat4 | float | int") -> "mat4":
        if isinstance(other, mat4):
            self.x += other.x; self.y += other.y; self.z += other.z; self.w += other.w; return self
        if isinstance(other, (float, int)):
            self.x += other; self.y += other; self.z += other; self.w += other; return self
        return NotImplemented
    

    def __isub__(self : "mat4", other : "mat4 | float | int") -> "mat4":
        if isinstance(other, mat4):
            self.x -= other.x; self.y -= other.y; self.z -= other.z; self.w -= other.w; return self
        if isinstance(other, (float, int)):
            self.x -= other; self.y -= other; self.z -= other; self.w -= other; return self
        return NotImplemented
    

    def __imul__(self : "mat4", other : "mat4 | vec4 | float | int") -> "mat4 | vec4":
        if isinstance(other, mat4):
            self = self * other; return self
        if isinstance(other, vec4):
            r = self * other; other.x = r.x; other.y = r.y; other.z = r.z; other.w = r.w; return self
        if isinstance(other, (float, int)):
            self.x *= other; self.y *= other; self.z *= other; self.w *= other; return self
        return NotImplemented
    

    def __neg__(self : "mat4") -> "mat4":
        return mat4(-self.x, -self.y, -self.z, -self.w)


    def __pos__(self : "mat4") -> "mat4":
        return mat4(+self.x, +self.y, +self.z, +self.w)


def mag_sqrd(v : vec_type) -> float:
    if isinstance(v, vec_type):
        return sum(v * v)
    raise ValueError("mag_sqrd() only accepts types of 'vec_type' (vec2, vec3, vec4)")


def mag(v : vec_type) -> float:
    if isinstance(v, vec_type):
        return math.sqrt(sum(v * v))
    raise ValueError("mag() only accepts types of 'vec_type' (vec2, vec3, vec4)")
    

def inv_mag_sqrd(v : vec_type) -> float:
    if isinstance(v, vec_type):
        return 1.0 / sum(v * v)
    raise ValueError("inv_mag_sqrd() only accepts types of 'vec_type' (vec2, vec3, vec4)")


def inv_mag(v : vec_type) -> float:
    if isinstance(v, vec_type):
        return 1.0 / math.sqrt(sum(v * v))
    raise ValueError("inv_mag() only accepts types of 'vec_type' (vec2, vec3, vec4)")


def normalize(v : vec_type) -> vec_type:
    if isinstance(v, vec_type):
        return v * inv_mag(v)
    raise ValueError("normalize() only accepts types of 'vec_type' (vec2, vec3, vec4)")


def dot(v1 : vec_type, v2 : vec_type) -> float:
    if isinstance(v1, vec_type) and isinstance(v2, vec_type):
        return sum(v1 * v2)
    raise ValueError("dot() only accepts 'vec_type' types (vec2, vec3, vec4)")


def cross(v1 : vec3, v2 : vec3) -> vec3:
    if isinstance(v1, vec3) and isinstance(v2, vec3):
        return vec3(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x)
    raise ValueError("dot() only accepts 'vec3' types")


def lerp(v1 : vec_type, v2 : vec_type, t : float | vec_type) -> vec3:
    if isinstance(v1, vec_type) and isinstance(v2, vec_type) and isinstance(v2, (float, vec_type)):
        return v1 + t * (v2 - v1)
    raise ValueError("lerp()'s can only take 2 'vec_types' (vec2, vec3, vec4) and 1 'float' or 3 'vec_types'")


def reflect(v : vec_type, n : vec_type, o : vec_type = None) -> vec_type:
    if o:
        return (v - o) - ((sum((v - o) * n) * 2) * n)
    return v - ((sum(v * n) * 2) * n)


def to_vec2(v : vec_type) -> vec2:
    if isinstance(v, (vec3, vec4)):
        return vec2(v.x, v.y)
    if isinstance(v, vec2):
        return v
    raise ValueError("to_vec2() only accepts 'vec_type' types")


def to_vec3(v : vec_type) -> vec3:
    if isinstance(v, vec2):
        return vec3(v.x, v.y, 0.0)
    if isinstance(v, vec3):
        return v
    if isinstance(v, vec4):
        return vec4(v.x, v.y, v.z)
    raise ValueError("to_vec3() only accepts 'vec_type' types")


def to_vec4(v : vec_type) -> vec3:
    if isinstance(v, vec2):
        return vec4(v.x, v.y, 0.0, 0.0)
    if isinstance(v, vec3):
        return vec4(v.x, v.y, v.z, 0.0)
    if isinstance(v, vec4):
        return v
    raise ValueError("to_vec4() only accepts 'vec_type' types")


def rot_mat2_lhs(theta : float) -> mat2:
    c : float = math.cos(theta); s : float = math.sin(theta)
    return mat2(
        vec2(c,-s),
        vec2(s, c)
    )


def rot_mat2_rhs(theta : float) -> mat2:
    c : float = math.cos(theta); s : float = math.sin(theta)
    return mat2(
        vec2( c, s),
        vec2(-s, c)
    )


def rot_mat3_lhs(theta : float, offset : vec2 = vec2(0.0, 0.0)) -> mat3:
    c : float = math.cos(theta); s : float = math.sin(theta)
    return mat3(
        vec3(  c, -s,offset.x),
        vec3(  s,  c,offset.y),
        vec3(0.0,0.0,     1.0)
    )


def rot_mat3_rhs(theta : float, offset : vec2 = vec2(0.0, 0.0)) -> mat3:
    c : float = math.cos(theta); s : float = math.sin(theta)
    return mat3(
        vec3(       c,        s, 0.0),
        vec3(      -s,        c, 0.0),
        vec3(offset.x, offset.y, 1.0)
    )


def rot_x_mat3_lhs(theta : float) -> mat3:
    c : float = math.cos(theta); s : float = math.sin(theta)
    return mat3(
        vec3(1.0, 0.0, 0.0),
        vec3(0.0,   c,   s),
        vec3(0.0,  -s,   c)
    )


def polar(theta : float) -> vec2:
    return vec2(math.cos(theta), math.sin(theta))